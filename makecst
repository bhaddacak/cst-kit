#!/usr/bin/env bash

VERSION="0.5.2"
CCSA="<!--This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License-->"
MADEBY="<!--Generated by makecst v$VERSION (https://github.com/bhaddacak/cst-kit)-->"
DATE="<!--$(date -u)-->"

function show_help {
	echo ""
	echo "   MAKECST v$VERSION, CST text renderer"
	echo "   https://github.com/bhaddacak/cst-kit"
	echo ""
	echo "   Usage: ./makecst <output-format> [<file>]"
	echo ""
	echo "   Make sure you are running in a bash shell,"
	echo "       together with GNU sed and gzip installed."
	echo "   Available <output-format>:"
	echo "       xml  - Render to XML output (minimally converted)"
	echo "       html - Render to HTML output (not XSL transformation)"
	echo "       txt  - Render to text (headless HTML) output"
	echo "       gz   - Render to gz (headless HTML) output"
	echo "       bare - Render to bare text output (all tags stripped)"
	echo ""
	echo "   If a <file> is not given, the entire raw data will be rendered."
	echo "   Example:"
	echo "       ./makecst txt"
	echo "   This will produce headless HTML text files in directory 'txt'."
	echo "       ./makecst html raw/cst-v-buv1.xml"
	echo "   This will produce the HTML version of the file in the current directory."
	echo ""
}

function process_xml {
	local infile="$1"
	local outfile=$(basename "$infile")
	outfile="$OUTDIR/$outfile"
	sed -f cstformat-min.sed "$infile" > "$outfile"
	sed -i "/<body>/a\
		$CCSA\n$MADEBY\n$DATE" "$outfile"
	echo "$infile => $outfile"
}

function process_html {
	local infile="$1"
	local outfile=$(basename "$infile")
	outfile="$OUTDIR/${outfile%.xml}"
	sed -f cstformat-main.sed -f cstformat-htm.sed -f cstformat-min.sed "$infile" > "$outfile"
	sed -i "/<body>/,/<\/body>/!d;/<body>/a\
		$CCSA\n$MADEBY\n$DATE" "$outfile"
	local textname=$(sed -n '/"book"/p' "$infile" | sed -e "s/<p rend=\"book\">//g;s/<\/p>//g;" | sed -e "N;s/\n/, /g")
	sed -i "1i\
		<!DOCTYPE html>\n<html>\n<head>\n<title>$textname</title>\n</head>
			\$a\
		</html>" "$outfile"
	mv "$outfile" "$outfile.$MODE"
	echo "$infile => $outfile.$MODE"
}

function process_text {
	local infile="$1"
	local outfile=$(basename "$infile")
	outfile="$OUTDIR/${outfile%.xml}"
	sed -f cstformat-main.sed -f cstformat-txt.sed -f cstformat-min.sed "$infile" > "$outfile"
	sed -i "/<body>/,/<\/body>/!d;/<body>/a\
		$CCSA\n$MADEBY\n$DATE" "$outfile"
	sed -i "/<body>/d;/<\/body>/d" "$outfile"
	if [ "$MODE" = "gz" ]; then
		gzip "$outfile"
		ext="gz"
	elif [ "$MODE" = "txt" ]; then
		ext="txt.htm"
		mv "$outfile" "$outfile.$ext"
	fi
	echo "$infile => $outfile.$ext"
}

function process_bare {
	local infile="$1"
	local outfile=$(basename "$infile")
	outfile="$OUTDIR/${outfile%.xml}"
	sed -f cstformat-bare.sed -f cstformat-txt.sed -f cstformat-min.sed "$infile" > "$outfile"
	sed -i "/<body>/,/<\/body>/!d;/<body>/a\
		$CCSA\n$MADEBY\n$DATE" "$outfile"
	sed -i "/<body>/d;/<\/body>/d;s/<!--/# /;s/-->//" "$outfile"
	mv "$outfile" "$outfile.txt"
	echo "$infile => $outfile.txt"
}

## check input option
valid_mode=(xml html txt gz bare)
param_ok="n"
if [ -n $1 ]; then
	for m in ${valid_mode[*]}
	do
		if [ "${1@L}" = "$m" ]; then
			param_ok="y"
		fi
	done
fi

if [ $param_ok = "n" ]; then
	show_help
	exit
fi

## if option ok, do assignment
MODE=${1@L}
if [ -z "$2" ]; then
	OUTDIR="$1"
else
	OUTDIR="."
fi

count=0
if [ -f "$2" ]; then
	case $MODE in
		"xml") process_xml "$2" ;;
		"html") process_html "$2" ;;
		"txt" |	"gz") process_text "$2" ;;
		"bare") process_bare "$2" ;;
	esac
	((count++))
else
	[ -e "$OUTDIR" ] || mkdir "$OUTDIR"
	for item in raw/*.xml
	do
		case $MODE in
			"xml") process_xml "$item" ;;
			"html") process_html "$item" ;;
			"txt" |	"gz") process_text "$item" ;;
			"bare") process_bare "$item" ;;
		esac
		((count++))
	done
	if [ "$MODE" = "xml" ]; then
		cp raw/*.xsl "$OUTDIR"
		cp raw/*.css "$OUTDIR"
	fi
fi

echo "$count file(s) processed in $MODE mode"
